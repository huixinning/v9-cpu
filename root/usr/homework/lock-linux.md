##Non-scalable locks are dangerous

很多操作系统为了实现串行化采用的是不可扩展的所机制，例如linux内核采用的是排队自旋锁机制，但是在使用linux操作系统的48个核的机器上，不可扩展的所机制在实际的工作负载下会发生动态崩溃事件，因此为了改进这个问题，我们提出了可扩展的锁机制。

####本篇论文主要从三个方面来描述解决了问题
* 第一：不可扩展的锁在真正的负载下会导致系统性能的崩溃。
* 第二：在不可扩展的所机制下，随着core数增加，系统崩溃有可能随时发生。比如在N个core时系统会有很好的性能，但是core数一旦增加性能会突然降低。因此我们提出了一种专门面向不可扩展的所机制的模型，该模型可以很好的捕获所有操作的机制。
* 第三：有些时候仅仅几条肉眼可数的指令也有可能导致系统崩溃。

在本篇论文里为了解决上述问题，我们采用可扩展的锁机制，尤其是在那些负载和节点争夺很难控制的操作系统内核里。因此，我们采用可扩展的MCS所机制去代替linux的自旋锁机制并且重新运行那些可能导致性能崩溃的软件，并且我们证明了基于X-86操作系统的多核处理器进程MCS锁可以最大化的提高可扩展性。

####如何将普通的排队自旋锁变为可扩展的锁
第一种实现方式是在锁产生竞争的时候按照一定的比例进行补偿。
第二种实现方式就是使用真正的可扩展锁，可扩展锁是在每次要获得锁时产生一定数量的cache缺失，那么所有的锁就会产生一个等待队列，每个进程采用自己的锁机制进行等待，可扩展的锁包括：MCS, K42, CLH, HCLH

####MCS锁
MCS锁和linux的排队自旋锁最大的不同是它采用不同的API，当需要一个MCS锁的时候，core首先将一个qnode传递给mcs_lock，当释放锁的时候传递相同的qnode给mcs_unlock，对于每个拥有锁的core来说，他们都有一个自己的qnode，但是允许在采用不同锁的时候使用相同的qnode。在一般情况下，linux kernel要求使用锁和释放锁在不同的函数，然而MCS锁机制却是在相同的函数结构里面。

####结论
实验结果表明，可扩展的所机制不仅不会使额外的工作量增加，还可以有效的避免由于不可扩展的所机制带来的性能崩塌问题，后续给我们带来的好处是我们的体系结构会在接下来的很多年都使用相同的kernel，所以即使随着core数量的增加有可能会给性能带来翻倍式的增长。
